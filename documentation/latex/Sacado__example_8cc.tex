\hypertarget{Sacado__example_8cc}{}\section{Sacado\+\_\+example.\+cc File Reference}
\label{Sacado__example_8cc}\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
{\ttfamily \#include $<$deal.\+I\+I/base/symmetric\+\_\+tensor.\+h$>$}\\*
{\ttfamily \#include $<$iostream$>$}\\*
{\ttfamily \#include $<$fstream$>$}\\*
{\ttfamily \#include $<$cmath$>$}\\*
{\ttfamily \#include $<$Sacado.\+hpp$>$}\\*
{\ttfamily \#include \char`\"{}Sacado\+\_\+\+Wrapper.\+h\char`\"{}}\\*
Include dependency graph for Sacado\+\_\+example.\+cc\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{Sacado__example_8cc__incl}
\end{center}
\end{figure}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\+\_\+double} = Sacado\+::\+Fad\+::\+D\+Fad$<$ double $>$
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\+\_\+test\+\_\+scalar} ()
\item 
void \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\+\_\+test\+\_\+2} ()
\item 
void \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\+\_\+test\+\_\+3} ()
\item 
void \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\+\_\+test\+\_\+3B} ()
\item 
void \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\+\_\+test\+\_\+4} ()
\item 
void \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\+\_\+test\+\_\+5} ()
\item 
int \hyperlink{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main} ()
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!fad\+\_\+double@{fad\+\_\+double}}
\index{fad\+\_\+double@{fad\+\_\+double}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{fad\+\_\+double}{fad_double}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf fad\+\_\+double} =  Sacado\+::\+Fad\+::\+D\+Fad$<$double$>$}\hypertarget{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{}\label{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}


\subsection{Function Documentation}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!main@{main}}
\index{main@{main}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{main()}{main()}}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{}\label{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}


References sacado\+\_\+test\+\_\+2(), sacado\+\_\+test\+\_\+3(), sacado\+\_\+test\+\_\+3\+B(), sacado\+\_\+test\+\_\+4(), sacado\+\_\+test\+\_\+5(), and sacado\+\_\+test\+\_\+scalar().


\begin{DoxyCode}
482 \{
483     \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\_test\_scalar} ();
484 
485     std::cout << std::endl;
486 
487     \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\_test\_2} ();
488 
489     std::cout << std::endl;
490 
491     \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\_test\_3} ();
492 
493     std::cout << std::endl;
494 
495     \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\_test\_3B} ();
496 
497     std::cout << std::endl;
498 
499     \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\_test\_4}();
500 
501     std::cout << std::endl;
502 
503     \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\_test\_5}();
504 
505 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}}
\index{sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+2()}{sacado_test_2()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+2 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{}\label{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}


Referenced by main().


\begin{DoxyCode}
66 \{
67     std::cout << \textcolor{stringliteral}{"Tensor Test 2:"} << std::endl;
68 
69     \textcolor{comment}{// First we set the dimension \(\backslash\)a dim: 2D->dim=2; 3D->dim=3 \(\backslash\)n This defines the "size" of the tensors
       and the number of dofs. Ex2 only works in 3D, whereas the following Ex3 is set up dimension-independent.}
70     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
71 
72     \textcolor{comment}{// Declare our input, auxiliary and output variables as SymmetricTensors consisting of fad\_doubles
       (instead of the standard SymmetricTensor out of doubles)}
73     SymmetricTensor<2,dim, fad\_double> sigma, eps;
74 
75     \textcolor{comment}{// Init the strain tensor (the point at which the derivative shall be computed)}
76     eps[0][0] = 1;
77     eps[1][1] = 2;
78     eps[2][2] = 3;
79     eps[0][1] = 4;
80     eps[0][2] = 5;
81     eps[1][2] = 6;
82 
83     \textcolor{comment}{// Now we declare the dofs. The derivative to a tensor requires all components, therefore we set the
       components of the strain tensor here one by one as the dofs.}
84     \textcolor{comment}{// Because our tensors are symmetric, we only need 6 components in 3D instead of 9 for a full second
       order tensor}
85     eps[0][0].diff(0,6);
86     eps[1][1].diff(1,6);
87     eps[2][2].diff(2,6);
88     eps[0][1].diff(3,6);
89     eps[0][2].diff(4,6);
90     eps[1][2].diff(5,6);
91 
92     \textcolor{comment}{// The equation describing the stresses (here just a simple test case)}
93     sigma = eps;
94 
95     \textcolor{comment}{// Let's output the computed stress tensor.}
96     std::cout << sigma << std::endl;
97     \textcolor{comment}{// The resulting values of \(\backslash\)a sigma are fairly boring, due to our simple equation. It is the additional
       output generated by}
98     \textcolor{comment}{// this, that is interesting here: \(\backslash\)n}
99     \textcolor{comment}{// output: \(\backslash\)n}
100     \textcolor{comment}{// 1 [ 1 0 0 0 0 0 ] 4 [ 0 0 0 1 0 0 ] 5 [ 0 0 0 0 1 0 ] 4 [ 0 0 0 1 0 0 ] 2 [ 0 1 0 0 0 0 ] 6 [ 0 0 0
       0 0 1 ] 5 [ 0 0 0 0 1 0 ] 6 [ 0 0 0 0 0 1 ] 3 [ 0 0 1 0 0 0 ] \(\backslash\)n}
101     \textcolor{comment}{// The numbers 1, 4, 5, 4, ... are the entries in the stress tensor \(\backslash\)a sigma. In square brackets we see
       the derivatives of sigma with respect to all the dofs set previously}
102     \textcolor{comment}{// given in the order we defined them above. Meaning: The first entry in the square brackets
       corresponds to the 0-th dof set by}
103     \textcolor{comment}{// @code eps[0][0].diff(0,6); @endcode referring to the component (0,0) in the strain tensor \(\backslash\)a eps.}
104 
105     \textcolor{comment}{// Computing the derivatives for certain components of the resulting tangent modulus: \(\backslash\)n}
106     \textcolor{comment}{// We now access these lists of derivatives (output above in square brackets) for one component of the
       stress tensor \(\backslash\)a sigma at a time.}
107     \{
108         \textcolor{comment}{// Access the derivatives corresponding to the component (0,0) of the stress tensor \(\backslash\)a sigma}
109         \textcolor{keywordtype}{double} *derivs = &sigma[0][0].fastAccessDx(0);
110         \textcolor{comment}{// The following output will show us the same derivatives that we already saw above, just formatted
       differently \(\backslash\)n}
111         \textcolor{comment}{// output: d\_sigma[0][0]/d\_eps = 1 , 0 , 0 , 0 , 0 , 0 ,}
112         std::cout << \textcolor{stringliteral}{"d\_sigma[0][0]/d\_eps = "};
113         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
114             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
115         std::cout << std::endl;
116     \}
117     \{
118         \textcolor{comment}{// Access the derivatives corresponding to the component (1,2) of the stress tensor \(\backslash\)a sigma}
119         \textcolor{keywordtype}{double} *derivs = &sigma[1][2].fastAccessDx(0);
120         \textcolor{comment}{// output: d\_sigma[1][2]/d\_eps = 0 , 0 , 0 , 0 , 0 , 1 ,}
121         std::cout << \textcolor{stringliteral}{"d\_sigma[1][2]/d\_eps = "};
122         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
123             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
124         std::cout << std::endl;
125     \}
126 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}}
\index{sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+3()}{sacado_test_3()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+3 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{}\label{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}


Referenced by main().


\begin{DoxyCode}
131 \{
132     std::cout << \textcolor{stringliteral}{"Tensor Test 3:"} << std::endl;
133 
134     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
135 
136     \textcolor{comment}{// Here we also define some constant, for instance the bulk modulus \(\backslash\)a kappa and the second Lamè
       parameter \(\backslash\)a mu.}
137     \textcolor{comment}{// We now also define one of our constants as fad\_double. By doing this we can use the normal
       multiplication (see below).}
138     \textcolor{keywordtype}{double} kappa\_param = 5;
139     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} kappa (kappa\_param);
140     \textcolor{comment}{// The second constant remains as a double just to show the difference.}
141     \textcolor{keywordtype}{double} mu = 2;
142 
143     SymmetricTensor<2,dim, fad\_double> sigma, eps;
144 
145     \textcolor{comment}{// To simplify the access to the dofs we define a map that relate the components of our strain tensor
       to the dof-nbr}
146     std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
147 
148     \textcolor{comment}{// The point at which the derivative shall be computed: \(\backslash\)n}
149     \textcolor{comment}{// As mentioned previously, we will implement this example for 2D and 3D, hence we once have to set up
       a strain tensor}
150     \textcolor{comment}{// and the derivatives for 3D with 6 independent components ...}
151     \textcolor{keywordflow}{if}(dim==3)
152     \{
153         eps[0][0] = 1;
154         eps[1][1] = 2;
155         eps[2][2] = 3;
156         
157         eps[0][1] = 4;
158         eps[0][2] = 5;
159         eps[1][2] = 6;
160         
161         
162         eps[0][0].diff(0,6);
163         eps[0][1].diff(1,6);
164         eps[0][2].diff(2,6);
165         eps[1][1].diff(3,6);
166         eps[1][2].diff(4,6);
167         eps[2][2].diff(5,6);
168         
169         \textcolor{comment}{// By using the map and the following pairs, we have to set up the relation between strain
       components and dofs only once}
170         \textcolor{comment}{// and can use the map to access the entries of the list later, without possibly mixing up indices
       and creating errors}
171         std::pair<unsigned int, unsigned int> tmp\_pair;
172         tmp\_pair.first=0; tmp\_pair.second=0;
173         std\_map\_indicies[0] = tmp\_pair;
174 
175         tmp\_pair.first=0; tmp\_pair.second=1;
176         std\_map\_indicies[1] = tmp\_pair;
177 
178         tmp\_pair.first=0; tmp\_pair.second=2;
179         std\_map\_indicies[2] = tmp\_pair;
180 
181         tmp\_pair.first=1; tmp\_pair.second=1;
182         std\_map\_indicies[3] = tmp\_pair;
183 
184         tmp\_pair.first=1; tmp\_pair.second=2;
185         std\_map\_indicies[4] = tmp\_pair;
186 
187         tmp\_pair.first=2; tmp\_pair.second=2;
188         std\_map\_indicies[5] = tmp\_pair;
189     \}
190     \textcolor{comment}{// ... and once for 2D with just 3 independent components.}
191     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
192     \{
193         eps[0][0] = 1;
194         eps[1][1] = 2;
195         
196         eps[0][1] = 4;
197 
198                 
199         eps[0][0].diff(0,3);
200         eps[0][1].diff(1,3);
201         eps[1][1].diff(2,3);
202         
203         std::pair<unsigned int, unsigned int> tmp\_pair;
204         tmp\_pair.first=0; tmp\_pair.second=0;
205         std\_map\_indicies[0] = tmp\_pair;
206         
207         tmp\_pair.first=0; tmp\_pair.second=1;
208         std\_map\_indicies[1] = tmp\_pair;
209         
210         tmp\_pair.first=1; tmp\_pair.second=1;
211         std\_map\_indicies[2] = tmp\_pair;        
212     \}
213     \textcolor{keywordflow}{else}
214     \{
215         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
216     \}
217 
218     \textcolor{comment}{// Instead of calling the *.diff(*) on the components one-by-one we could also use the following
       for-loop, so}
219     \textcolor{comment}{// we also use the map to set the dofs}
220     \textcolor{comment}{// @code}
221     \textcolor{comment}{// for ( unsigned int x=0; x<((dim==2)?3:6); ++x )}
222     \textcolor{comment}{// \{}
223     \textcolor{comment}{//  unsigned int i=std\_map\_indicies[x].first;}
224     \textcolor{comment}{//  unsigned int j=std\_map\_indicies[x].second;}
225     \textcolor{comment}{//  eps[i][j].diff(x,((dim==2)?3:6));}
226     \textcolor{comment}{// \}}
227     \textcolor{comment}{// @endcode}
228 
229     \textcolor{comment}{// For our slightly more complicated stress equation we need the unit and deviatoric tensors.}
230     \textcolor{comment}{// We can simply define them by writing the values of the already existing deal.ii functions into newly}
231     \textcolor{comment}{// defined SymmetricTensors build from fad\_doubles.}
232     SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
233     SymmetricTensor<4,dim, fad\_double> stdTensor\_Idev ( (deviator\_tensor<dim,fad\_double>()) );
234     
235     \textcolor{comment}{// With everything set and defined, we can compute our stress \(\backslash\)a sigma according to:}
236     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)kappa \(\backslash\)cdot trace(\(\backslash\)varepsilon) \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)varepsilon^\{dev\} \(\backslash\)f]}
237     \textcolor{comment}{// Here you can see that we can directly multiply the constant and the tensors when kappa is also
       declared as fad\_double}
238     sigma = kappa * (trace(eps) *  stdTensor\_I);
239     \textcolor{comment}{// We didn't do the same for mu to once again emphasize the difference between constants as double and
       as fad\_double. \(\backslash\)n}
240     \textcolor{comment}{// The remaining code uses a normal double constant.}
241     SymmetricTensor<2,dim,fad\_double> tmp = deviator<dim,fad\_double>(symmetrize<dim,fad\_double>(eps)); tmp*
      =(mu*2);
242     sigma +=  tmp;
243     \textcolor{comment}{// The fairly cumbersome computation is caused by the way the operators are set up for tensors out of
       fad\_doubles.}
244     
245     std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
246 
247     \textcolor{comment}{// Now we want to actually build our tangent modulus called \(\backslash\)a C\_Sacado that contains all the
       derivatives and relates}
248     \textcolor{comment}{// the stress tensor with the strain tensor. \(\backslash\)n}
249     \textcolor{comment}{// The fourth-order tensor \(\backslash\)a C\_Sacado is our final goal, we don't have to compute anything that is
       related to Sacado with}
250     \textcolor{comment}{// this tensor, so we can finally return to our standard SymmetricTensor out of doubles. The latter is
       necessary to use}
251     \textcolor{comment}{// the tangent in the actual FE code.}
252     SymmetricTensor<4,dim> C\_Sacado;
253 
254     \textcolor{comment}{// As in Ex2 we access the components of the stress tensor one by one. In order to capture all of them
       we sum over the}
255     \textcolor{comment}{// components i and j of the stress tensor.}
256     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
257         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
258         \{
259             \textcolor{keywordtype}{double} *derivs = &sigma[i][j].fastAccessDx(0); \textcolor{comment}{// Access the derivatives of the (i,j)-th
       component of \(\backslash\)a sigma}
260 
261             \textcolor{comment}{// To visually ensure that every stress component has in fact all 6 derivatives for 3D or 3 for
       2D, we output the size:}
262             std::cout<<\textcolor{stringliteral}{"size: "}<<sigma[i][j].size()<<std::endl;
263 
264             \textcolor{comment}{// We loop over all the dofs. To be able to use this independent of the chosen dimension \(\backslash\)a
       dim, we use a ternary operator}
265             \textcolor{comment}{// to decide whether we have to loop over 6 derivatives or just 3.}
266             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<((dim==2)?3:6);++x)
267             \{
268                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
269                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
270 
271                 \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
272                 \{
273                     C\_Sacado[i][j][k][l] = 0.5*derivs[x];
274                     C\_Sacado[i][j][l][k] = 0.5*derivs[x];
275                 \}
276                 \textcolor{keywordflow}{else}
277                     C\_Sacado[i][j][k][l] = derivs[x];
278             \}            
279             
280         \}
281 
282     \textcolor{comment}{// After resembling the fourth-order tensor, we now have got our tangent saved in \(\backslash\)a C\_Sacado ready to
       be used}
283 
284     \textcolor{comment}{// To ensure that Sacado works properly, we can compute the analytical tangent for comparison}
285     \textcolor{keywordtype}{double} kappa\_d = 5;
286     \textcolor{keywordtype}{double} mu\_d = 2;
287     \textcolor{comment}{// Our stress equation in this example is still simple enough to derive the tangent analytically by
       hand:}
288     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)overset\{4\}\{C\_\{analy\}\} = \(\backslash\)kappa \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} \(\backslash\)otimes \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)overset\{4\}\{I^\{dev\}\} \(\backslash\)f]}
289     SymmetricTensor<4,dim> C\_analy = kappa\_d * outer\_product(unit\_symmetric\_tensor<dim>(), 
      unit\_symmetric\_tensor<dim>()) + 2* mu\_d * deviator\_tensor<dim>();
290 
291 
292     \textcolor{comment}{// We again define our strain tensor \(\backslash\)a eps\_d (*\_d for standard double in contrast to fad\_double)}
293     SymmetricTensor<2,dim> eps\_d;
294     
295     \textcolor{keywordflow}{if}(dim==3)
296     \{
297         eps\_d[0][0] = 1;
298         eps\_d[1][1] = 2;
299         eps\_d[2][2] = 3;
300         
301         eps\_d[0][1] = 4;
302         eps\_d[0][2] = 5;
303         eps\_d[2][1] = 6;
304 
305     \}
306     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
307     \{
308         eps\_d[0][0] = 1;
309         eps\_d[1][1] = 2;
310         
311         eps\_d[1][0] = 4;
312         
313     \}
314     \textcolor{keywordflow}{else}
315     \{
316         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
317     \}
318     \textcolor{comment}{// @todo use boldsymbol for tensors}
319     \textcolor{comment}{//}
320     \textcolor{comment}{// To output the stress tensor we first have to compute it. We do this here via}
321     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)overset\{4\}\{C\_\{analy\}\} : \(\backslash\)varepsilon \(\backslash\)f]}
322     \textcolor{comment}{// The output exactly matched the result obtained with Sacado.}
323     \textcolor{comment}{// @note Checking the Sacado stress tensor against an analytically computed or otherwise determined
       stress tensor is absolutely no way to check whether}
324     \textcolor{comment}{// the tangent computed via Sacado is correct. When we compute the stress tensor with Sacado and for
       example mix up a + and - sign, this might not matter}
325     \textcolor{comment}{// at all if the number that is added or subtracted is small. However, for the tangent this nasty sign
       can be very critical. Just keep in mind: the}
326     \textcolor{comment}{// tangent has 81 components and the stress tensor just 9, so how does one want to verify 81 variables
       by comparing 9?}
327     \textcolor{comment}{//}
328     std::cout << \textcolor{stringliteral}{"sigma\_analy: "} << (C\_analy*eps\_d) << std::endl;
329     
330     \textcolor{comment}{// That's the reason we compare all the entries in the Sacado and the analytical tensor one by one}
331     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
332         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
333             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
334                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
335                     std::cout << \textcolor{stringliteral}{"C\_analy["}<<i<<\textcolor{stringliteral}{"]["}<<j<<\textcolor{stringliteral}{"]["}<<k<<\textcolor{stringliteral}{"]["}<<l<<\textcolor{stringliteral}{"] = "} << C\_analy[i][j][k][l] <<
       \textcolor{stringliteral}{" vs C\_Sacado: "} << C\_Sacado[i][j][k][l] << std::endl;
336 
337 
338     \textcolor{comment}{// To simplify the comparison we compute a scalar error as the sum of the absolute differences of each
       component}
339     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
340     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
341         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
342             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
343                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
344                     error\_Sacado\_vs\_analy += std::fabs(C\_Sacado[i][j][k][l] - C\_analy[i][j][k][l]);
345                     
346 
347     \textcolor{comment}{// As desired: The numerical error is zero (0 in double precision) and the tensor components are equal}
348     std::cout << \textcolor{stringliteral}{"numerical error: "} << error\_Sacado\_vs\_analy << std::endl;
349 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}}
\index{sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+3\+B()}{sacado_test_3B()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+3B (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{}\label{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}


References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
354 \{
355     std::cout << \textcolor{stringliteral}{"Tensor Test 3B:"} << std::endl;
356     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
357 
358     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor and the
       constants out of doubles.}
359     SymmetricTensor<2,dim> eps\_d;
360     eps\_d[0][0] = 1;
361     eps\_d[1][1] = 2;
362     eps\_d[2][2] = 3;
363 
364     eps\_d[0][1] = 4;
365     eps\_d[0][2] = 5;
366     eps\_d[1][2] = 6;
367 
368     \textcolor{keywordtype}{double} kappa = 5;
369     \textcolor{keywordtype}{double} mu = 2;
370 
371     \textcolor{comment}{// Now we start working with Sacado: \(\backslash\)n}
372     \textcolor{comment}{// When we use the index notation to compute e.g. our stress we do not need to declare our constants
       (here kappa, mu) as}
373     \textcolor{comment}{// fad\_double.}
374 
375     \textcolor{comment}{// We declare our strain tensor as the special data type Sacado\_Wrapper::SymTensor from the file
       "Sacado\_Wrapper.h"}
376     \textcolor{comment}{// where this data type was derived from the SymmetricTensor<2,dim,fad\_double>.}
377      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
378 
379     \textcolor{comment}{// Next we initialize our Sacado strain tensor with the values of the inputed double strain tensor:}
380      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
381 
382     \textcolor{comment}{// We define all the entries in the symmetric tensor \(\backslash\)a eps as the dofs. So we can later derive any
       variable}
383     \textcolor{comment}{// with respect to the strain tensor \(\backslash\)a eps.}
384      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ae5e13d654682e392f39dc0991bdd95a2}{set\_dofs}();
385 
386     \textcolor{comment}{// Now we declare our output and auxiliary variables as Sacado-Tensors.}
387      SymmetricTensor<2,dim,fad\_double> sigma;
388 
389      SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
390 
391      \textcolor{comment}{// Our stress equation is now computed in index notation to simplfiy the use of the constants and}
392      \textcolor{comment}{// especially the use of the \(\backslash\)a deviator.}
393       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
394         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
395             sigma[i][j] = kappa * trace(eps) *  stdTensor\_I[i][j] + 2. * mu * deviator(eps)[i][j];
396 
397     \textcolor{comment}{// Finally we declare our desired tangent as the fourth order tensor \(\backslash\)a C\_Sacado and compute the
       tangent via}
398     \textcolor{comment}{// the command \(\backslash\)a get\_tangent.}
399      SymmetricTensor<4,dim> C\_Sacado;
400      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
401 
402     \textcolor{comment}{// We could again compare the herein computed tangent with the analytical tangent from Ex2, but as
       before}
403     \textcolor{comment}{// the results are fairly boring, because Sacado hits the analytical tangent exactly --- no surprise
       for such}
404     \textcolor{comment}{// simple equations.}
405 
406     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can achieve everything from Ex2 (besides the
       equations)}
407     \textcolor{comment}{// with just four lines of code namely:}
408     \textcolor{comment}{// - eps.init(eps\_d);    // To initialize the Sacado strain tensor}
409     \textcolor{comment}{// - eps.set\_dofs();     // To declare the components of eps as the dofs}
410     \textcolor{comment}{// - eps.get\_tangent(*); // To get the tangent}
411 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}}
\index{sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+4()}{sacado_test_4()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+4 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{}\label{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}


References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
416 \{
417     std::cout << \textcolor{stringliteral}{"Tensor Test 4:"} << std::endl;
418     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
419 
420     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor \(\backslash\)q eps\_d,}
421     \textcolor{comment}{// the damage variable \(\backslash\)a phi and the constants \(\backslash\)a kappa and \(\backslash\)a mu out of doubles.}
422     SymmetricTensor<2,dim> eps\_d;
423     eps\_d[0][0] = 1;
424     eps\_d[1][1] = 2;
425     eps\_d[2][2] = 3;
426 
427     eps\_d[0][1] = 4;
428     eps\_d[0][2] = 5;
429     eps\_d[1][2] = 6;
430 
431     \textcolor{keywordtype}{double} phi = 0.3;
432 
433     \textcolor{keywordtype}{double} kappa = 5;
434     \textcolor{keywordtype}{double} mu = 2;
435 
436     \textcolor{comment}{// We set up our strain tensor as in Ex3B.}
437     \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
438     eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
439     eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ae5e13d654682e392f39dc0991bdd95a2}{set\_dofs}();
440 
441     \textcolor{comment}{// In order to also compute derivatives with respect to the scalar \(\backslash\)a phi, we add this scalar to our
       list}
442     \textcolor{comment}{// of derivatives:}
443     \textcolor{comment}{// @todo CONTINUE HERE}
444 
445 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}}
\index{sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+5()}{sacado_test_5()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+5 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{}\label{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}


Referenced by main().


\begin{DoxyCode}
450 \{
451     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
452     std::cout << \textcolor{stringliteral}{"Tensor Test 5:"} << std::endl;
453     Tensor<1,dim,fad\_double> c;
454     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b;
455     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_dofs=2;
456     a = 1; b = 2;   \textcolor{comment}{// at the point (a,b) = (1,2)}
457     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
458     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
459     \textcolor{comment}{// c is now a vector with three components}
460     c[0] = 2*a+3*b;
461     c[1] = 4*a+5*b;
462     c[2] = 6*a+7*b;
463     
464     \textcolor{comment}{// Access to the derivatives works as before.}
465     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<dim;++i)
466     \{
467         \textcolor{keyword}{const} \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} &derivs = c[i]; \textcolor{comment}{// Access derivatives}
468         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0;j<n\_dofs;++j)
469         \{
470             std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{") for "}
471             <<i<<\textcolor{stringliteral}{"th component wrt "}<<j<<\textcolor{stringliteral}{"th direction "}<< std::endl;
472             std::cout << \textcolor{stringliteral}{"dc\_i/dxj = "} << derivs.fastAccessDx(j) << std::endl;            
473         \}
474     \}
475 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}}
\index{sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+scalar()}{sacado_test_scalar()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+scalar (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{}\label{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}


Referenced by main().


\begin{DoxyCode}
38 \{
39     std::cout << \textcolor{stringliteral}{"Scalar Test:"} << std::endl;
40     \textcolor{comment}{// define the variables used in the computation (inputs: a, b; output: c; auxiliaries: *) as the
       Sacado-data type}
41      \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b,c;
42     \textcolor{comment}{// initialize the input variables a and b; This (a,b) = (1,2) will be the point where the derivatives
       are computed.}
43     \textcolor{comment}{// Compare: y=x² -> (dy/dx)(\(\backslash\)@x=1) = 2. We can only compute the derivative numerically at a certain
       point.}
44      a = 1;
45      b = 2;
46 
47     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
48     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
49     \textcolor{comment}{// Our equation here is very simply. But you can use nested equations and many standard mathematical
       operations, such as sqrt, pow, sin, ...}
50     c = 2*a + std::cos(a*b);
51     \textcolor{keywordtype}{double} *derivs = &c.fastAccessDx(0); \textcolor{comment}{// Access the derivatives of}
52     \textcolor{comment}{// Output the derivatives of c with respect to the two above defined degrees of freedom (dof)}
53     std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
54     std::cout << \textcolor{stringliteral}{"dc/da = "} << derivs[0] << \textcolor{stringliteral}{", dc/db="} << derivs[1] << std::endl;
55 \}
\end{DoxyCode}
